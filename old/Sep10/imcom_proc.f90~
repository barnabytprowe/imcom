!
! Contains basic procedures for the imcom package
!
!--------------------------------------------------------------------

MODULE imcom_proc

USE imcom_data

implicit none

CONTAINS

FUNCTION imcom_xarr(n1, n2)
! Outputs an array of x values at the centre of pixels, starting at (0., 0.)
! etc. (all of the values in any particular column will be identical)
implicit none
integer, intent(IN) :: n1, n2              ! x and y dimensions of image
real(KIND=8), dimension(n1, n2) :: imcom_xarr ! output
integer :: i
real(KIND=8), dimension(n1) :: x 

x = (/ (real(i, 8) - 1.d0, i=1, n1) /)
imcom_xarr = spread(x, 2, n2)
END FUNCTION imcom_xarr

!---

FUNCTION imcom_yarr(n1, n2)
! Outputs an array of y values at the centre of pixels, starting at (0., 0.)
! etc. (all of the values in any particular row will be identical)
implicit none
integer, intent(IN) :: n1, n2      ! x and y dimensions of image
real(KIND=8), dimension(n1, n2) :: imcom_yarr  ! output

imcom_yarr = transpose(imcom_xarr(n2, n1))
END FUNCTION imcom_yarr

!---

SUBROUTINE imcom_build_xy
! Make the x, y, x_i & x_i (including dimension check) arrays for the
! galaxy images
implicit none
integer :: alstat, dealstat, i

allocate(x(n1gim, n2gim, nexp), y(n1gim, n2gim, nexp), STAT=alstat)
if (alstat.ne.0) then
  write(*, FMT='(A)')"IMCOM ERROR: Cannot allocate memory for x, y"
  stop
endif
do i=1, nexp

  x(:, :, i) = imcom_xarr(n1gim, n2gim) * gimxscale(i) + dither(i, 1)
  y(:, :, i) = imcom_yarr(n1gim, n2gim) * gimyscale(i) + dither(i, 2)

end do
if (size(x).ne.n) then
  write(*, FMT='(A)') "IMCOM ERROR: Dimensions of x do not match x_i!?"
  stop
endif
if (size(y).ne.n) then
  write(*, FMT='(A)') "IMCOM ERROR: Dimensions of y do not match y_i!?"
  stop
endif
allocate(x_i(n), y_i(n), STAT=alstat)
if (alstat.ne.0) then
  write(*, FMT='(A)')"IMCOM ERROR: Cannot allocate memory for x_i, y_i"
  stop
endif
x_i = 0.d0
y_i = 0.d0
x_i = reshape(x, (/ n /))
y_i = reshape(y, (/ n /))
deallocate(x, y, STAT=dealstat)
if (alstat.ne.0) then
  write(*, FMT='(A)')"IMCOM ERROR: Cannot deallocate memory for x, y"
  stop
endif
END SUBROUTINE imcom_build_xy

!---

SUBROUTINE imcom_build_XaYa
! Make the x, y arrays for the galaxy images
implicit none
integer :: alstat, dealstat

allocate(Xa(n1out, n2out), Ya(n1out, n2out), STAT=alstat)
if (alstat.ne.0) then
  write(*, FMT='(A)')"IMCOM ERROR: Cannot allocate memory for Xa, Ya"
  stop
endif
Xa(:, :) = imcom_xarr(n1out, n2out) * outxscale + outpos1
Ya(:, :) = imcom_yarr(n1out, n2out) * outyscale + outpos2
allocate(X_a(m), Y_a(m), STAT=alstat)
if (alstat.ne.0) then
  write(*, FMT='(A)')"IMCOM ERROR: Cannot allocate memory for X_a, Y_a"
  stop
endif
X_a = 0.d0
Y_a = 0.d0
X_a = reshape(Xa, (/ m /))
Y_a = reshape(Ya, (/ m /))
deallocate(Xa, Ya, STAT=dealstat)
if (dealstat.ne.0) then
  write(*, FMT='(A)')"IMCOM ERROR: Cannot deallocate memory for Xa, Ya"
  stop
endif
END SUBROUTINE imcom_build_XaYa

!---

SUBROUTINE imcom_build_uxuy
! Make the ux, uy arrays for the PSF images...
implicit none
integer :: alstat, j

allocate(ux(n1psf, n2psf), uy(n1psf, n2psf), STAT=alstat)
if (alstat.ne.0) then
  write(*, FMT='(A)')"IMCOM ERROR: Cannot allocate memory for ux, uy"
  stop
endif
ux = 0.d0
uy = 0.d0
if (mod(n1psf, 2).eq.0) then
  ux(1 : 1 + n1psf / 2, :) = imcom_xarr(1 + n1psf / 2, n2psf) &
                           / psfxscale / real(n1psf, 8)
  forall(j=1 : n1psf / 2 - 1) ux(1 + j + n1psf / 2, :) &
                           = -ux(1 - j + n1psf / 2, :)
else
  ux(1 : 1 + n1psf / 2, :) = imcom_xarr(1 + n1psf / 2, n2psf) &
                           / psfxscale / real(n1psf, 8)
  forall(j=1 : n1psf / 2) ux(1 + j + n1psf / 2, :) &
                       = -ux(2 - j + n1psf / 2, :)
end if
if (mod(n2psf, 2).eq.0) then
  uy(:, 1 : 1 + n2psf / 2) = imcom_yarr(n1psf, 1 + n2psf / 2) &
                           / psfyscale / real(n2psf, 8)
  forall(j=1 : n2psf / 2 - 1) uy(:, 1 + j + n2psf / 2) &
                           = -uy(:, 1 - j + n2psf / 2)
else
  uy(:, 1 : 1 + n2psf / 2) = imcom_yarr(n1psf, 1 + n2psf / 2) &
                           / psfyscale / real(n2psf, 8)
  forall(j=1 : n2psf / 2) uy(:, 1 + j + n2psf / 2) &
                       = -uy(:, 2 - j + n2psf / 2)
end if
END SUBROUTINE imcom_build_uxuy

!---

SUBROUTINE imcom_rotate_xy(x_dum, y_dum, theta_deg, xp_dum, yp_dum)
! Linearly rotate arrays of x and y to give a new x' and y'
!
implicit none
real(KIND=8), dimension(:, :), intent(IN) :: x_dum, y_dum
real(KIND=8), intent(IN) :: theta_deg
real(KIND=8), dimension(size(x_dum, 1), size(x_dum, 2)), intent(OUT) :: xp_dum, yp_dum
real(KIND=8) :: theta_rad

if (size(x_dum, 1).ne.size(y_dum, 1)) then
  write(*, FMT='(A)') "IMCOM ERROR: X and Y input to IMCOM_ROTATE_XY of unequal dimensions"
  stop
endif
if (size(x_dum, 2).ne.size(y_dum, 2)) then
  write(*, FMT='(A)') "IMCOM ERROR: X and Y input to IMCOM_ROTATE_XY of unequal dimensions"
  stop
endif
theta_rad = mod(theta_deg, 360.d0) * pi / 180.d0
xp_dum =  x_dum * cos(theta_rad) - y_dum * sin(theta_rad)
yp_dum =  x_dum * sin(theta_rad) + y_dum * cos(theta_rad)
END SUBROUTINE imcom_rotate_xy

!---

SUBROUTINE imcom_rotate_image(im_in, theta_deg, im_out, conserve_flux)
! Linearly rotate an image about its centre using blinear interpolation 
! (...code up bicubic?) 
!
implicit none
real(KIND=8), dimension(:, :), intent(IN) :: im_in
real(KIND=8), intent(IN) :: theta_deg
integer, intent(IN) :: conserve_flux
real(KIND=8), dimension(size(im_in, 1), size(im_in, 2)), intent(OUT) :: im_out
real(KIND=8) :: theta_rad, cost, sint
integer :: nim1, nim2
real(KIND=8) :: xs, ys, x_cent, y_cent
integer :: is_floor, is_ceiling, js_floor, js_ceiling
real(KIND=8) :: xout, yout
integer :: iout, jout
real(KIND=8) :: int1, int2, delx, dely ! delx, dely < 1

theta_rad = mod(theta_deg, 360.d0) * pi / 180.d0
cost = cos(theta_rad)
sint = sin(theta_rad)
nim1 = size(im_in, 1)
nim2 = size(im_in, 2)
x_cent = real(nim1 + 1, 8) / 2.d0
y_cent = real(nim2 + 1, 8) / 2.d0
im_out = 0.d0
do iout=1, nim1

  xout = real(iout, 8) - x_cent
  do jout=1, nim2

    yout = real(jout, 8) - y_cent
    xs =  xout * cost + yout * sint
    ys = -xout * sint + yout * cost
    is_floor = floor(xs + x_cent)
    js_floor = floor(ys + y_cent)
    is_ceiling = ceiling(xs + x_cent)
    js_ceiling = ceiling(ys + y_cent)
    delx = xs + x_cent - real(is_floor, 8)
    dely = ys + y_cent - real(js_floor, 8)
    if ((is_floor.gt.0).and.(js_floor.gt.0)      &
                       .and.(is_ceiling.le.nim1) &
                       .and.(js_ceiling.le.nim2)) then
      int1 = (1.d0 - delx) * im_in(is_floor, js_floor) &
           + delx * im_in(is_ceiling, js_floor)
      int2 = (1.d0 - delx) * im_in(is_floor, js_ceiling) &
           + delx * im_in(is_ceiling, js_ceiling)
      im_out(iout, jout) = (1.d0 - dely) * int1 + dely * int2
    else
      im_out(iout, jout) = 0.d0
    end if

  end do

end do
if (conserve_flux.ne.0) im_out = sum(im_in) * im_out / sum(im_out)
END SUBROUTINE imcom_rotate_image

!---

SUBROUTINE imcom_rotate_cimage(im_in, theta_deg, im_out, conserve_flux)
! Linearly rotate a complex image about its centre using blinear interpolation 
! (...code up bicubic?) 
!
implicit none
complex(KIND=8), dimension(:, :), intent(IN) :: im_in
real(KIND=8), intent(IN) :: theta_deg
integer, intent(IN) :: conserve_flux
complex(KIND=8), dimension(size(im_in, 1), size(im_in, 2)), intent(OUT) :: im_out
real(KIND=8), dimension(size(im_in, 1), size(im_in, 2)) :: rin, rout
real(KIND=8), dimension(size(im_in, 1), size(im_in, 2)) :: iin, iout
real(KIND=8) :: flux_in, flux_out

im_out = dcmplx(0.d0, 0.d0)
rin = real(im_in, 8)
iin = dimag(im_in)
call imcom_rotate_image(rin, theta_deg, rout, 0)
call imcom_rotate_image(iin, theta_deg, iout, 0)
im_out = dcmplx(rout, iout)
if (conserve_flux.ne.0) then
  flux_in = sum(abs(im_in))
  flux_out = sum(abs(im_out))
  im_out = dcmplx(flux_in, 0.d0) * im_out / dcmplx(flux_out, 0.d0)
endif
END SUBROUTINE imcom_rotate_cimage

!---

FUNCTION imcom_upsilon(ux_dum, uy_dum, option)
! Real symmetric positive definite kernel (p2, combo.pdf)
!
implicit none
real(KIND=8), intent(IN) :: ux_dum
real(KIND=8), intent(IN) :: uy_dum
integer, intent(IN) :: option
complex(KIND=8) :: imcom_upsilon  ! output var

if (option.eq.1) then
  imcom_upsilon = dcmplx(1.d0, 0.d0)
else if (option.eq.2) then
  imcom_upsilon = zexp(-dcmplx((ux_dum * ux_dum + uy_dum * uy_dum), 0.d0))
else
  imcom_upsilon = dcmplx(0.d0, 0.d0)
  write(*, FMT='(A)') "IMCOM ERROR: Upsilon function must take OPTION = 1 or 2"
  stop
end if
END FUNCTION imcom_upsilon

!---

FUNCTION imcom_upsilon2D(ux_dum, uy_dum, option)
! Real symmetric positive definite kernel (p2, combo.pdf)
implicit none
real(KIND=8), dimension(:, :), intent(IN) :: ux_dum
real(KIND=8), dimension(:, :), intent(IN) :: uy_dum
integer, intent(IN) :: option
complex(KIND=8), dimension(size(ux_dum, 1), size(uy_dum, 2)) :: imcom_upsilon2D 
! output var

if (size(ux_dum, 1).ne.size(uy_dum, 1).or.size(ux_dum, 2).ne.size(uy_dum, 2)) then
!  write(*, FMT='(A)') "IMCOM ERROR: UX and UY arguments to UPSILON must be equal shape"
!  stop
endif
if (option.eq.1) then
  imcom_upsilon2D = dcmplx(1.d0, 0.d0)
else if (option.eq.2) then
  imcom_upsilon2D = zexp(-dcmplx((ux_dum * ux_dum + uy_dum * uy_dum), 0.d0))
else
  imcom_upsilon2D = dcmplx(0.d0, 0.d0)
  write(*, FMT='(A)') "IMCOM ERROR: Upsilon2D function must take OPTION = 1 or 2"
  stop
end if
END FUNCTION imcom_upsilon2D

!---

PURE FUNCTION imcom_dsinc(x)
implicit none
real(KIND=8), intent(IN) :: x
real(KIND=8) :: imcom_dsinc     ! Output variable
real(KIND=8) :: xx

xx = dabs(x)
if (xx.lt.1.d-15) then
  imcom_dsinc = 1.d0
else
  imcom_dsinc = dsin(pi * x) / x / pi
end if
END FUNCTION imcom_dsinc

!---

PURE FUNCTION imcom_dsinc2(x)
implicit none
real(KIND=8), intent(IN) :: x
real(KIND=8) :: imcom_dsinc2    ! Output variable
real(KIND=8) :: xx, sintmp

xx = dabs(x)
if (xx.lt.1.d-15) then
  imcom_dsinc2 = 1.d0
else
  sintmp = dsin(pi * x)
  imcom_dsinc2 = sintmp * sintmp / x / x / pi / pi
end if
END FUNCTION imcom_dsinc2

!---

SUBROUTINE imcom_ft_r2c(n1, n2, F_dum, Ft_dum, info)
! Perform the real-to-complex Discrete Fourier Transform using the linked
! FFTW3 library routines... NOTE this currently only ESTIMATES the best plan 
! for performing the DFT and doesn't MEASURE it (see FFTW docs)
implicit none
integer, intent(IN) :: n1, n2, info
real(KIND=8), dimension(0 : n1 - 1, 0 : n2 - 1), intent(IN) :: F_dum
complex(KIND=8), dimension(0 : n1 - 1, 0 : n2 - 1), intent(OUT) :: Ft_dum
real(KIND=8), dimension(0: n1 - 1, 0: n2 - 1) :: F_tmp
complex(KIND=8), dimension(0: n1 / 2, 0 : n2 - 1) :: Ft_tmp
complex(KIND=8), dimension(0: n1 / 2, 0 : n2 - 1) :: Ft_conj
integer(KIND=8) :: plan
integer :: i

call DFFTW_PLAN_DFT_R2C_2D(plan, n1, n2, F_tmp, Ft_tmp, &
                           FFTW_ESTIMATE + FFTW_PRESERVE_INPUT)
if (info.ne.0) then 
  call DFFTW_PRINT_PLAN(plan)
  print *, F_dum(0:info-1, 1)
endif
F_tmp = real(F_dum, 8)     ! Fill working array with data before FFT
call DFFTW_EXECUTE_DFT_R2C(plan, F_tmp, Ft_tmp)
call DFFTW_DESTROY_PLAN(plan)
! From FFTW3 documentation:
!In many practical applications, the input data in[i] are purely real numbers, in which case the DFT output satisfies the Hermitian redundancy: out[i] is the conjugate of out[n-i]. It is possible to take advantage of these circumstances in order to achieve roughly a factor of two improvement in both speed and memory usage.
!
! Fix this...
Ft_conj = dconjg(Ft_tmp)
Ft_dum(0 : n1 / 2, :) = Ft_tmp(0 : n1 / 2, :)
Ft_dum(n1 / 2 + 1 : n1 - 1, 0) = Ft_conj(n1 / 2 - 1 : 1 : -1, 0)
forall(i = 1 : (n1 - 1) / 2) Ft_dum(n1 / 2 + i, 1 : n2 - 1) &
                           = Ft_conj(n1 / 2 - i, n2 - 1 : 1 : -1)

END SUBROUTINE imcom_ft_r2c

!---

SUBROUTINE imcom_ft_c2c(n1, n2, F_dum, Ft_dum, info)
! Perform the complex-to-complex Discrete Fourier Transform using the linked
! FFTW3 library routines... NOTE this currently only ESTIMATES the best plan 
! for performing the DFT and doesn't MEASURE it (see FFTW docs)
implicit none
integer, intent(IN) :: n1, n2, info
complex(KIND=8), dimension(n1, n1), intent(IN) :: F_dum
complex(KIND=8), dimension(n1, n2), intent(OUT) :: Ft_dum
complex(KIND=8), dimension(n1, n2) :: F_tmp
complex(KIND=8), dimension(n1, n2) :: Ft_tmp
integer(KIND=8) :: plan

call DFFTW_PLAN_DFT_2D(plan, n1, n2, F_tmp, Ft_tmp, FFTW_FORWARD, &
                       FFTW_ESTIMATE + FFTW_PRESERVE_INPUT)
if (info.ne.0) then 
  call DFFTW_PRINT_PLAN(plan)
  print *, F_dum(1:info, 1)
endif
F_tmp = F_dum     ! Fill working array with data before FFT
call DFFTW_EXECUTE_DFT(plan, F_tmp, Ft_tmp)
call DFFTW_DESTROY_PLAN(plan)
Ft_dum = Ft_tmp   ! Fill output array with FFT 
END SUBROUTINE imcom_ft_c2c

!---

SUBROUTINE imcom_invft_c2c(n1, n2, Ft_dum, F_dum, info)
! Perform the complex-to-complex inverse Discrete Fourier Transform using 
! the linked FFTW3 library routines... NOTE this currently only ESTIMATES the 
! best plan for performing the DFT and doesn't MEASURE it (see FFTW docs)
implicit none
integer, intent(IN) :: n1, n2, info
complex(KIND=8), dimension(n1, n1), intent(IN) :: Ft_dum
complex(KIND=8), dimension(n1, n2), intent(OUT) :: F_dum
complex(KIND=8), dimension(n1, n2) :: F_tmp
complex(KIND=8), dimension(n1, n2) :: Ft_tmp
integer(KIND=8) :: plan

call DFFTW_PLAN_DFT_2D(plan, n1, n2, Ft_tmp, F_tmp, FFTW_BACKWARD, &
                       FFTW_ESTIMATE + FFTW_PRESERVE_INPUT)
if (info.ne.0) then 
  call DFFTW_PRINT_PLAN(plan)
  print *, Ft_dum(1:info, 1)
endif
Ft_tmp = Ft_dum     ! Fill working array with data before FFT
call DFFTW_EXECUTE_DFT(plan, Ft_tmp, F_tmp)
call DFFTW_DESTROY_PLAN(plan)
F_dum = F_tmp       ! Fill output array with inverse FFT 
END SUBROUTINE imcom_invft_c2c

!---

END MODULE imcom_proc
